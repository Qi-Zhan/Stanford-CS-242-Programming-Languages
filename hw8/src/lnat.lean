--=======================
-- DO NOT EDIT THIS FILE
--=======================

--=======================
-- IMPORTANT:
--   Before working on Problem 1, you should read the below
--   definitions and comments (especially, those staring with
--   "NOTES") to understand how $Lnat$ is formalized in this file.
--=======================

--=======================
-- Below parts are used from Problem 1.
--=======================

-- Op --
inductive Op
| Add
| Sub
| Mul
| Div

-- example on Op: `Op.Add` denotes the operator $+$. --
example : Op := Op.Add

-- Expr --
inductive Expr
| Num : ℕ → Expr
| Op  : Op → Expr → Expr → Expr

-- NOTES on `Expr`:
--
--   In our formalization, an expression of $Lnat$ is represented
--   as a term of type `Expr`. The type `Expr` is defined as an
--   inductive type using the `inductive` keyword. Here are two
--   examples showing how to construct an expression in our
--   formalization:
example : Expr := Expr.Num 1
example : Expr := Expr.Op Op.Add (Expr.Num 1) (Expr.Num 2)
--   The examples denote expressions $1$ and $1+2$, respectively.

-- val --
inductive val : Expr → Prop
| VNum (n : ℕ) : val (Expr.Num n)

-- NOTES on `val`:
--
--   Basically, `val e` denotes the judgement $e val$. `val` is
--   defined as an inductive type (precisely, an inductive family)
--   using the `inductive` keyword, so that we can perform inductive
--   proofs on the judgment.
--
--   The type of `val` is `Expr → Prop`, meaning that `val` is
--   a function that takes a term of type `Expr` and returns
--   a proposition (i.e., a term of type `Prop`). In other words,
--   `val e` is a proposition for any term `e` of type `Expr`.
--   Even though `val e` is a proposition for all `e : Expr`,
--   the proposition is true (i.e., has a proof) only for some
--   particular terms `e`. Those particular terms `e` that make
--   `val e` true are defined by the constructors of `val`.
--
--   The only constructor of `val` is `VNum`, which corresponds to 
--   the only inference rule of $e val$ (i.e., the rule V-Num).
--   The constructor `VNum` takes a term `n` of type `ℕ` and
--   returns a term of type `val (Expr.Num n)` (i.e., a proof
--   of the proposition `val (Expr.Num n)`). In other words,
--   `val.VNum n` is a proof of the proposition `val (Expr.Num n)`.
--  
--   Here is an example of `val e` and its proof:
example : val (Expr.Num 2) := val.VNum 2
--   `val (Expr.Num 2)` is a proposition denoting the judgement
--   $2 val$, and `val.VNum 2` is a proof of the proposition.

--=======================
-- Below parts are used from Problem 2.
--=======================

-- apply_op --
def apply_op (op : Op) (n1 n2 : ℕ) : ℕ :=
  Op.cases_on op (n1 + n2) (n1 - n2) (n1 * n2) (n1 / n2)

-- eval (i.e., e ↦ e') --
inductive eval : Expr → Expr → Prop
| ELeft (op : Op) (e1 e1' e2 : Expr) :
  eval e1 e1'
  → eval (Expr.Op op e1 e2)
         (Expr.Op op e1' e2)

| ERight (op : Op) (e1 e2 e2' : Expr) :
  eval e2 e2'
  → val e1
  → eval (Expr.Op op e1 e2)
         (Expr.Op op e1 e2')

| EOp (op: Op) (n1 n2 : ℕ) :
  eval (Expr.Op op (Expr.Num n1) (Expr.Num n2))
       (Expr.Num (apply_op op n1 n2))

notation e `↦`:35 e' := eval e e'

-- NOTES on `eval`:
--
--   Basically, `eval e e'` (or equivalently, `e ↦ e'`) denotes
--   the judgement $e ↦ e'$. `eval` is defined as an inductive
--   family using the `inductive` keyword, as `val` does. So we
--   can perform inductive proofs on the judgment `eval e e'`.
--
--   The type of `eval` is `Expr → Expr → Prop`, meaning that
--   `eval` is a function that takes two terms of type `Expr`
--   and returns a proposition (i.e., a term of type `Prop`).
--   In other words, `eval e e'` is a proposition for any terms
--   `e` and `e'` of type `Expr`. As with `val`, `eval e e'` is
--   a proposition for all `e : Expr` and `e' : Expr`, but the
--   proposition is true (i.e., has a proof) only for some
--   particular terms `e` and `e'`. Those particular terms `e`
--   and `e'` that make `eval e e'` true are defined by the
--   constructors of `eval`.
--
--   `eval` has three constructors: `ELeft`, `ERight` and `EOp`,
--   which correspond to the three inference rule of $e ↦ e'$.
--   For instance, the constructor `ELeft` takes a term `op` of
--   type `Op` and three terms (`e1`, `e1'`, and `e2`) of type
--   `Expr`; then it returns a term of type
--     `eval e1 e1' → eval (Expr.Op op e1 e2) (Expr.Op op e1' e2)`,
--   i.e., returns a proof of the proposition
--     `eval e1 e1' → eval (Expr.Op op e1 e2) (Expr.Op op e1' e2)`.
--   The proposition states that if $e1 ↦ e1'$ holds, then 
--   $(e1 op e2) ↦ (e1' op e2)$ holds. Note that this is exactly
--   the rule E-Left. The other two inference rules of $e ↦ e'$
--   are formalized similarly in `eval`.
--  
--   Here is an example of `e ↦ e'` (i.e., `eval e e'`) and its
--   proofs, one using proof terms and the other using tactics:
example :
  (Expr.Op Op.Add (Expr.Num 1) (Expr.Num 2)) ↦ (Expr.Num 3) :=
  eval.EOp Op.Add 1 2
example :
  (Expr.Op Op.Add (Expr.Num 1) (Expr.Num 2)) ↦ (Expr.Num 3) :=
begin
  apply eval.EOp,
end 
--   `(Expr.Op ...) ↦ (Expr.Num 3)` is a proposition denoting
--   the judgement $(1+2) ↦ 3$. `eval.EOp Op.Add 1 2` shown in
--   the first example is a proof of the proposition.

--=======================
-- Below parts are used from Problem 4.
--=======================

-- evals (i.e., e ↦* e') --
inductive evals : Expr → Expr → Prop
| CRefl (e : Expr) :
  evals e e

| CStep (e e' e'': Expr) :
  (e ↦ e')
  → evals e' e''
  → evals e e''

notation e `↦*`:35 e' := evals e e'

-- NOTES on `evals`:
--
--   `evals e e'` (or equivalently, `e ↦* e'`) denotes the
--   judgment $e ↦* e'$. Below is an example of the judgement:
example :
  (Expr.Op Op.Add (Expr.Num 1) (Expr.Num 2)) ↦* (Expr.Num 3) :=
  evals.CStep
    (Expr.Op Op.Add (Expr.Num 1) (Expr.Num 2))
    (Expr.Num 3)
    (Expr.Num 3)
    (eval.EOp Op.Add 1 2)
    (evals.CRefl (Expr.Num 3))
example :
  (Expr.Op Op.Add (Expr.Num 1) (Expr.Num 2)) ↦* (Expr.Num 3) :=
begin
  apply evals.CStep,
    show Expr, from Expr.Num 3,
    apply eval.EOp,
    apply evals.CRefl,
end
--   `(Expr.Op ...) ↦* (Expr.Num 3)` is a proposition denoting
--   the judgement $(1+2) ↦* 3$. `evals.CStep ...` shown in the
--   first example is a proof of the proposition.

-- lemma: reflexivity of e ↦* e' --
@[refl]
lemma evals_refl (e : Expr) :
  e ↦* e :=
begin
  apply evals.CRefl,
end

-- lemma: transitivity e ↦* e' --
@[trans]
lemma evals_trans (e e' e'' : Expr) :
  (e ↦* e') → (e' ↦* e'') → (e ↦* e'') :=
begin
  intros h1 h2,
  induction h1,
  case evals.CRefl : e {
    assumption
  },
  case evals.CStep : e emid e' {
    apply evals.CStep e emid e'',
      assumption,
      exact h1_ih h2,
  },
end
