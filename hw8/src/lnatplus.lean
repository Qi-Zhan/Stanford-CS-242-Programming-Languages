--=======================
-- DO NOT EDIT THIS FILE
--=======================

--=======================
-- IMPORTANT:
--   Before working on Problem 8, you should read the below
--   definitions understand how $Lnat+$ is formalized in this file.
--=======================

--=======================
-- This file is used from Problem 8.
--=======================

-- Op --
inductive Op 
| Add
| Sub
| Mul
| Div

-- Expr --
inductive Expr
| Num : ℕ → Expr
| Op  : Op → Expr → Expr → Expr
| Var : ℕ → Expr
| Let : Expr → Expr → Expr

-- val --
-- NOTES: `val e` denotes the judgement $e val$.
inductive val : Expr → Prop
| VNum (n : ℕ) : val (Expr.Num n)

-- apply_op --
def apply_op (op : Op) (n1 n2 : ℕ) : ℕ :=
  Op.cases_on op (n1 + n2) (n1 - n2) (n1 * n2) (n1 / n2)

-- subst --
-- NOTES: `subst i e' e eres` denotes the equality
--          $eres = e [ \hat{i} := e' ]$,
--        where the RHS is the result of applying the
--        substitution operator to $e$ with $\hat{i}$ and $e'$.
inductive subst : ℕ → Expr → Expr → Expr → Prop
| SNum (i n : ℕ) (e' : Expr) :
  subst i e' (Expr.Num n) (Expr.Num n)

| SOp (op : Op) (i : ℕ) (e1 e2 e1' e2' e' : Expr) :
  subst i e' e1 e1'
  → subst i e' e2 e2'
  → subst i e' (Expr.Op op e1 e2) (Expr.Op op e1' e2')

| SVarEq (i j : ℕ) (e' : Expr) :
  i = j
  → subst i e' (Expr.Var j) e'

| SVarNeq (i j : ℕ) (e' : Expr) :
  i ≠j
  → subst i e' (Expr.Var j) (Expr.Var j)

| SLet (e1 e2 e1' e2' e' : Expr) (i : ℕ) :
  subst i e' e1 e1'
  → subst (i+1) e' e2 e2'
  → subst i e' (Expr.Let e1 e2) (Expr.Let e1' e2')

-- eval (i.e., e ↦ e') --
-- NOTES: `eval e e'` denotes the judgment $e ↦ e'$.
inductive eval : Expr → Expr → Prop
| ELeft (op : Op) (e1 e1' e2 : Expr) :
  eval e1 e1'
  → eval (Expr.Op op e1 e2)
         (Expr.Op op e1' e2)

| ERight (op : Op) (e1 e2 e2' : Expr) :
  eval e2 e2'
  → val e1
  → eval (Expr.Op op e1 e2)
         (Expr.Op op e1 e2')

| EOp (op: Op) (n1 n2 : ℕ) :
  eval (Expr.Op op (Expr.Num n1) (Expr.Num n2))
       (Expr.Num (apply_op op n1 n2))

-- TYPO: DLet should be understood as ELet. --
| DLet (e1 e2 e2' : Expr) :
  subst 0 e1 e2 e2'
  → eval (Expr.Let e1 e2) e2'

notation e `↦`:35 e' := eval e e'

-- typnat --
-- NOTES: `typnat i e` denotes the judgment $Γ ⊢ e : nat$.
inductive typnat : ℕ → Expr → Prop
| TNum (n i : ℕ) :
  typnat i (Expr.Num n)

| TOp (op : Op) (e1 e2 : Expr) (i : ℕ) :
  typnat i e1
  → typnat i e2
  → typnat i (Expr.Op op e1 e2)

| TVar (j i : ℕ) :
  j < i
  → typnat i (Expr.Var j)

| TLet (e1 e2 : Expr) (i : ℕ) :
  typnat i e1
  → typnat (i+1) e2
  → typnat i (Expr.Let e1 e2)
